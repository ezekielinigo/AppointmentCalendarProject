import _extends from "@babel/runtime/helpers/esm/extends";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import { passFilterLogic } from '@mui/x-data-grid-pro/internals';
import { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';
export var GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = '__row_group_by_columns_group__';
export var ROW_GROUPING_STRATEGY = 'grouping-columns';
export var getRowGroupingFieldFromGroupingCriteria = function getRowGroupingFieldFromGroupingCriteria(groupingCriteria) {
  if (groupingCriteria === null) {
    return GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD;
  }
  return "__row_group_by_columns_group_".concat(groupingCriteria, "__");
};
export var getRowGroupingCriteriaFromGroupingField = function getRowGroupingCriteriaFromGroupingField(groupingColDefField) {
  var match = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);
  if (!match) {
    return null;
  }
  return match[1];
};
export var isGroupingColumn = function isGroupingColumn(field) {
  return field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null;
};
/**
 * When filtering a group, we only want to filter according to the items related to this grouping column.
 */
var shouldApplyFilterItemOnGroup = function shouldApplyFilterItemOnGroup(columnField, node) {
  if (columnField === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {
    return true;
  }
  var groupingCriteriaField = getRowGroupingCriteriaFromGroupingField(columnField);
  return groupingCriteriaField === node.groupingField;
};

/**
 * A leaf is visible if it passed the filter
 * A group is visible if all the following criteria are met:
 * - One of its children is passing the filter
 * - It is passing the filter
 */
export var filterRowTreeFromGroupingColumns = function filterRowTreeFromGroupingColumns(params) {
  var apiRef = params.apiRef,
    rowTree = params.rowTree,
    isRowMatchingFilters = params.isRowMatchingFilters,
    filterModel = params.filterModel;
  var filteredRowsLookup = {};
  var filteredDescendantCountLookup = {};
  var filterCache = {};
  var filterTreeNode = function filterTreeNode(node, areAncestorsExpanded, ancestorsResults) {
    var filterResults = {
      passingFilterItems: null,
      passingQuickFilterValues: null
    };
    var isPassingFiltering = false;
    if (isRowMatchingFilters && node.type !== 'footer') {
      var shouldApplyItem = node.type === 'group' && node.isAutoGenerated ? function (columnField) {
        return shouldApplyFilterItemOnGroup(columnField, node);
      } : undefined;
      var row = apiRef.current.getRow(node.id);
      isRowMatchingFilters(row, shouldApplyItem, filterResults);
    } else {
      isPassingFiltering = true;
    }
    var filteredDescendantCount = 0;
    if (node.type === 'group') {
      node.children.forEach(function (childId) {
        var childNode = rowTree[childId];
        var childSubTreeSize = filterTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded, [].concat(_toConsumableArray(ancestorsResults), [filterResults]));
        filteredDescendantCount += childSubTreeSize;
      });
    }
    if (isPassingFiltering === false) {
      if (node.type === 'group') {
        // If node has children - it's passing if at least one child passes filters
        isPassingFiltering = filteredDescendantCount > 0;
      } else {
        var allResults = [].concat(_toConsumableArray(ancestorsResults), [filterResults]);
        isPassingFiltering = passFilterLogic(allResults.map(function (result) {
          return result.passingFilterItems;
        }), allResults.map(function (result) {
          return result.passingQuickFilterValues;
        }), filterModel, params.apiRef, filterCache);
      }
    }
    filteredRowsLookup[node.id] = isPassingFiltering;
    if (!isPassingFiltering) {
      return 0;
    }
    filteredDescendantCountLookup[node.id] = filteredDescendantCount;
    if (node.type !== 'group') {
      return filteredDescendantCount + 1;
    }
    return filteredDescendantCount;
  };
  var nodes = Object.values(rowTree);
  for (var i = 0; i < nodes.length; i += 1) {
    var node = nodes[i];
    if (node.depth === 0) {
      filterTreeNode(node, true, []);
    }
  }
  return {
    filteredRowsLookup: filteredRowsLookup,
    filteredDescendantCountLookup: filteredDescendantCountLookup
  };
};
export var getColDefOverrides = function getColDefOverrides(groupingColDefProp, fields) {
  if (typeof groupingColDefProp === 'function') {
    return groupingColDefProp({
      groupingName: ROW_GROUPING_STRATEGY,
      fields: fields
    });
  }
  return groupingColDefProp;
};
export var mergeStateWithRowGroupingModel = function mergeStateWithRowGroupingModel(rowGroupingModel) {
  return function (state) {
    return _extends({}, state, {
      rowGrouping: _extends({}, state.rowGrouping, {
        model: rowGroupingModel
      })
    });
  };
};
export var setStrategyAvailability = function setStrategyAvailability(privateApiRef, disableRowGrouping) {
  var isAvailable;
  if (disableRowGrouping) {
    isAvailable = function isAvailable() {
      return false;
    };
  } else {
    isAvailable = function isAvailable() {
      var rowGroupingSanitizedModel = gridRowGroupingSanitizedModelSelector(privateApiRef);
      return rowGroupingSanitizedModel.length > 0;
    };
  }
  privateApiRef.current.setStrategyAvailability('rowTree', ROW_GROUPING_STRATEGY, isAvailable);
};
export var getCellGroupingCriteria = function getCellGroupingCriteria(_ref) {
  var row = _ref.row,
    id = _ref.id,
    colDef = _ref.colDef,
    groupingRule = _ref.groupingRule;
  var key;
  if (groupingRule.groupingValueGetter) {
    var groupingValueGetterParams = {
      colDef: colDef,
      field: groupingRule.field,
      value: row[groupingRule.field],
      id: id,
      row: row,
      rowNode: {
        isAutoGenerated: false,
        id: id
      }
    };
    key = groupingRule.groupingValueGetter(groupingValueGetterParams);
  } else {
    key = row[groupingRule.field];
  }
  return {
    key: key,
    field: groupingRule.field
  };
};
export var getGroupingRules = function getGroupingRules(_ref2) {
  var sanitizedRowGroupingModel = _ref2.sanitizedRowGroupingModel,
    columnsLookup = _ref2.columnsLookup;
  return sanitizedRowGroupingModel.map(function (field) {
    var _columnsLookup$field;
    return {
      field: field,
      groupingValueGetter: (_columnsLookup$field = columnsLookup[field]) == null ? void 0 : _columnsLookup$field.groupingValueGetter
    };
  });
};

/**
 * Compares two sets of grouping rules to determine if they are equal or not.
 */
export var areGroupingRulesEqual = function areGroupingRulesEqual(newValue, previousValue) {
  if (previousValue.length !== newValue.length) {
    return false;
  }
  return newValue.every(function (newRule, newRuleIndex) {
    var previousRule = previousValue[newRuleIndex];
    if (previousRule.groupingValueGetter !== newRule.groupingValueGetter) {
      return false;
    }
    if (previousRule.field !== newRule.field) {
      return false;
    }
    return true;
  });
};