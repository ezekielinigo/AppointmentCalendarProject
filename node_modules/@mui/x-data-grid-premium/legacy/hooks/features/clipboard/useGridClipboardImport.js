import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import * as React from 'react';
import { GRID_CHECKBOX_SELECTION_FIELD, gridFocusCellSelector, gridVisibleColumnFieldsSelector, useGridApiOptionHandler, useGridApiEventHandler, gridPaginatedVisibleSortedGridRowIdsSelector, gridExpandedSortedRowIdsSelector, useGridLogger } from '@mui/x-data-grid';
import { buildWarning, getRowIdFromRowModel, getActiveElement, useGridRegisterPipeProcessor, getPublicApiRef } from '@mui/x-data-grid/internals';
import { GRID_DETAIL_PANEL_TOGGLE_FIELD, GRID_REORDER_COL_DEF } from '@mui/x-data-grid-pro';
import { unstable_debounce as debounce } from '@mui/utils';
var missingOnProcessRowUpdateErrorWarning = buildWarning(['MUI: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.', 'To handle the error pass a callback to the `onProcessRowUpdateError` prop, e.g. `<DataGrid onProcessRowUpdateError={(error) => ...} />`.', 'For more detail, see http://mui.com/components/data-grid/editing/#server-side-persistence.'], 'error');
var columnFieldsToExcludeFromPaste = [GRID_CHECKBOX_SELECTION_FIELD, GRID_REORDER_COL_DEF.field, GRID_DETAIL_PANEL_TOGGLE_FIELD];

// Batches rows that are updated during clipboard paste to reduce `updateRows` calls
function batchRowUpdates(func, wait) {
  var rows = [];
  var debounced = debounce(function () {
    func(rows);
    rows = [];
  }, wait);
  return function (row) {
    rows.push(row);
    debounced();
  };
}
function getTextFromClipboard(_x) {
  return _getTextFromClipboard.apply(this, arguments);
} // Keeps track of updated rows during clipboard paste
function _getTextFromClipboard() {
  _getTextFromClipboard = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(rootEl) {
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          return _context3.abrupt("return", new Promise(function (resolve) {
            var focusedCell = getActiveElement(document);
            var el = document.createElement('input');
            el.style.width = '0px';
            el.style.height = '0px';
            el.style.border = 'none';
            el.style.margin = '0';
            el.style.padding = '0';
            el.style.outline = 'none';
            el.style.position = 'absolute';
            el.style.top = '0';
            el.style.left = '0';
            var handlePasteEvent = function handlePasteEvent(event) {
              var _event$clipboardData;
              el.removeEventListener('paste', handlePasteEvent);
              var text = (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.getData('text/plain');
              if (focusedCell instanceof HTMLElement) {
                focusedCell.focus({
                  preventScroll: true
                });
              }
              el.remove();
              resolve(text || '');
            };
            el.addEventListener('paste', handlePasteEvent);
            rootEl.appendChild(el);
            el.focus({
              preventScroll: true
            });
          }));
        case 1:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _getTextFromClipboard.apply(this, arguments);
}
var CellValueUpdater = /*#__PURE__*/function () {
  function CellValueUpdater(options) {
    _classCallCheck(this, CellValueUpdater);
    this.rowsToUpdate = {};
    this.updateRow = void 0;
    this.options = void 0;
    this.options = options;
    this.updateRow = batchRowUpdates(options.apiRef.current.updateRows, 50);
  }
  _createClass(CellValueUpdater, [{
    key: "updateCell",
    value: function updateCell(_ref) {
      var rowId = _ref.rowId,
        field = _ref.field,
        pastedCellValue = _ref.pastedCellValue;
      if (pastedCellValue === undefined) {
        return;
      }
      var _this$options = this.options,
        apiRef = _this$options.apiRef,
        getRowId = _this$options.getRowId;
      var colDef = apiRef.current.getColumn(field);
      if (!colDef || !colDef.editable) {
        return;
      }
      var row = this.rowsToUpdate[rowId] || _extends({}, apiRef.current.getRow(rowId));
      if (!row) {
        return;
      }
      var cellParams = apiRef.current.getCellParams(rowId, field);
      var parsedValue = pastedCellValue;
      if (colDef.pastedValueParser) {
        parsedValue = colDef.pastedValueParser(pastedCellValue, cellParams);
      } else if (colDef.valueParser) {
        parsedValue = colDef.valueParser(parsedValue, cellParams);
      }
      if (parsedValue === undefined) {
        return;
      }
      var rowCopy = _extends({}, row);
      if (typeof colDef.valueSetter === 'function') {
        rowCopy = colDef.valueSetter({
          value: parsedValue,
          row: rowCopy
        });
      } else {
        rowCopy[field] = parsedValue;
      }
      var newRowId = getRowIdFromRowModel(rowCopy, getRowId);
      if (String(newRowId) !== String(rowId)) {
        // We cannot update row id, so this cell value update should be ignored
        return;
      }
      this.rowsToUpdate[rowId] = rowCopy;
    }
  }, {
    key: "applyUpdates",
    value: function applyUpdates() {
      var _this = this;
      var _this$options2 = this.options,
        apiRef = _this$options2.apiRef,
        processRowUpdate = _this$options2.processRowUpdate,
        onProcessRowUpdateError = _this$options2.onProcessRowUpdateError;
      var rowsToUpdate = this.rowsToUpdate;
      var rowIdsToUpdate = Object.keys(rowsToUpdate);
      if (rowIdsToUpdate.length === 0) {
        apiRef.current.publishEvent('clipboardPasteEnd');
        return;
      }
      var handleRowUpdate = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(rowId) {
          var newRow, handleError, oldRow, finalRowUpdate;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                newRow = rowsToUpdate[rowId];
                if (!(typeof processRowUpdate === 'function')) {
                  _context.next = 16;
                  break;
                }
                handleError = function handleError(errorThrown) {
                  if (onProcessRowUpdateError) {
                    onProcessRowUpdateError(errorThrown);
                  } else {
                    missingOnProcessRowUpdateErrorWarning();
                  }
                };
                _context.prev = 3;
                oldRow = apiRef.current.getRow(rowId);
                _context.next = 7;
                return processRowUpdate(newRow, oldRow);
              case 7:
                finalRowUpdate = _context.sent;
                _this.updateRow(finalRowUpdate);
                _context.next = 14;
                break;
              case 11:
                _context.prev = 11;
                _context.t0 = _context["catch"](3);
                handleError(_context.t0);
              case 14:
                _context.next = 17;
                break;
              case 16:
                _this.updateRow(newRow);
              case 17:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[3, 11]]);
        }));
        return function handleRowUpdate(_x2) {
          return _ref2.apply(this, arguments);
        };
      }();
      var promises = rowIdsToUpdate.map(function (rowId) {
        // Wrap in promise that always resolves to avoid Promise.all from stopping on first error.
        // This is to avoid using `Promise.allSettled` that has worse browser support.
        return new Promise(function (resolve) {
          handleRowUpdate(rowId).then(resolve).catch(resolve);
        });
      });
      Promise.all(promises).then(function () {
        _this.rowsToUpdate = {};
        apiRef.current.publishEvent('clipboardPasteEnd');
      });
    }
  }]);
  return CellValueUpdater;
}();
function defaultPasteResolver(_ref3) {
  var pastedData = _ref3.pastedData,
    apiRef = _ref3.apiRef,
    updateCell = _ref3.updateCell,
    pagination = _ref3.pagination;
  var isSingleValuePasted = pastedData.length === 1 && pastedData[0].length === 1;
  var cellSelectionModel = apiRef.current.unstable_getCellSelectionModel();
  if (cellSelectionModel && apiRef.current.unstable_getSelectedCellsAsArray().length > 1) {
    Object.keys(cellSelectionModel).forEach(function (rowId, rowIndex) {
      var rowDataArr = pastedData[isSingleValuePasted ? 0 : rowIndex];
      var hasRowData = isSingleValuePasted ? true : rowDataArr !== undefined;
      if (!hasRowData) {
        return;
      }
      Object.keys(cellSelectionModel[rowId]).forEach(function (field, colIndex) {
        var cellValue = isSingleValuePasted ? rowDataArr[0] : rowDataArr[colIndex];
        updateCell({
          rowId: rowId,
          field: field,
          pastedCellValue: cellValue
        });
      });
    });
    return;
  }
  var visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef).filter(function (field) {
    if (columnFieldsToExcludeFromPaste.includes(field)) {
      return false;
    }
    return true;
  });
  var selectedRows = apiRef.current.getSelectedRows();
  if (selectedRows.size > 0 && !isSingleValuePasted) {
    // Multiple values are pasted starting from the first and top-most cell
    var pastedRowsDataCount = pastedData.length;

    // There's no guarantee that the selected rows are in the same order as the pasted rows
    selectedRows.forEach(function (row, rowId) {
      var rowData;
      if (pastedRowsDataCount === 1) {
        // If only one row is pasted - paste it to all selected rows
        rowData = pastedData[0];
      } else {
        rowData = pastedData.shift();
      }
      if (rowData === undefined) {
        return;
      }
      rowData.forEach(function (newCellValue, cellIndex) {
        updateCell({
          rowId: rowId,
          field: visibleColumnFields[cellIndex],
          pastedCellValue: newCellValue
        });
      });
    });
    return;
  }
  var selectedCell = gridFocusCellSelector(apiRef);
  if (!selectedCell) {
    return;
  }
  if (columnFieldsToExcludeFromPaste.includes(selectedCell.field)) {
    return;
  }
  var selectedRowId = selectedCell.id;
  var selectedRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(selectedRowId);
  var visibleRowIds = pagination ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridExpandedSortedRowIdsSelector(apiRef);
  var selectedFieldIndex = visibleColumnFields.indexOf(selectedCell.field);
  pastedData.forEach(function (rowData, index) {
    var rowId = visibleRowIds[selectedRowIndex + index];
    if (typeof rowId === 'undefined') {
      return;
    }
    for (var i = selectedFieldIndex; i < visibleColumnFields.length; i += 1) {
      var field = visibleColumnFields[i];
      var stringValue = rowData[i - selectedFieldIndex];
      updateCell({
        rowId: rowId,
        field: field,
        pastedCellValue: stringValue
      });
    }
  });
}
function isPasteShortcut(event) {
  return (event.ctrlKey || event.metaKey) && event.key === 'v';
}
export var useGridClipboardImport = function useGridClipboardImport(apiRef, props) {
  var _ref4, _props$experimentalFe, _apiRef$current$rootE;
  var processRowUpdate = props.processRowUpdate;
  var onProcessRowUpdateError = props.onProcessRowUpdateError;
  var getRowId = props.getRowId;
  var enableClipboardPaste = (_ref4 = !props.disableClipboardPaste && ((_props$experimentalFe = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe.clipboardPaste)) != null ? _ref4 : false;
  var rootEl = (_apiRef$current$rootE = apiRef.current.rootElementRef) == null ? void 0 : _apiRef$current$rootE.current;
  var logger = useGridLogger(apiRef, 'useGridClipboardImport');
  var splitClipboardPastedText = props.unstable_splitClipboardPastedText;
  var pagination = props.pagination,
    onBeforeClipboardPasteStart = props.onBeforeClipboardPasteStart;
  var handlePaste = React.useCallback( /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(params, event) {
      var focusedCell, cellMode, text, pastedData, cellUpdater;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (enableClipboardPaste) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return");
          case 2:
            if (isPasteShortcut(event)) {
              _context2.next = 4;
              break;
            }
            return _context2.abrupt("return");
          case 4:
            focusedCell = gridFocusCellSelector(apiRef);
            if (!(focusedCell !== null)) {
              _context2.next = 9;
              break;
            }
            cellMode = apiRef.current.getCellMode(focusedCell.id, focusedCell.field);
            if (!(cellMode === 'edit')) {
              _context2.next = 9;
              break;
            }
            return _context2.abrupt("return");
          case 9:
            if (rootEl) {
              _context2.next = 11;
              break;
            }
            return _context2.abrupt("return");
          case 11:
            _context2.next = 13;
            return getTextFromClipboard(rootEl);
          case 13:
            text = _context2.sent;
            if (text) {
              _context2.next = 16;
              break;
            }
            return _context2.abrupt("return");
          case 16:
            pastedData = splitClipboardPastedText(text);
            if (pastedData) {
              _context2.next = 19;
              break;
            }
            return _context2.abrupt("return");
          case 19:
            if (!onBeforeClipboardPasteStart) {
              _context2.next = 29;
              break;
            }
            _context2.prev = 20;
            _context2.next = 23;
            return onBeforeClipboardPasteStart({
              data: pastedData
            });
          case 23:
            _context2.next = 29;
            break;
          case 25:
            _context2.prev = 25;
            _context2.t0 = _context2["catch"](20);
            logger.debug('Clipboard paste operation cancelled');
            return _context2.abrupt("return");
          case 29:
            cellUpdater = new CellValueUpdater({
              apiRef: apiRef,
              processRowUpdate: processRowUpdate,
              onProcessRowUpdateError: onProcessRowUpdateError,
              getRowId: getRowId
            });
            apiRef.current.publishEvent('clipboardPasteStart', {
              data: pastedData
            });
            defaultPasteResolver({
              pastedData: pastedData,
              apiRef: getPublicApiRef(apiRef),
              updateCell: function updateCell() {
                cellUpdater.updateCell.apply(cellUpdater, arguments);
              },
              pagination: pagination
            });
            cellUpdater.applyUpdates();
          case 33:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[20, 25]]);
    }));
    return function (_x3, _x4) {
      return _ref5.apply(this, arguments);
    };
  }(), [apiRef, processRowUpdate, onProcessRowUpdateError, getRowId, enableClipboardPaste, rootEl, splitClipboardPastedText, pagination, onBeforeClipboardPasteStart, logger]);
  var checkIfCanStartEditing = React.useCallback(function (initialValue, _ref6) {
    var event = _ref6.event;
    if (isPasteShortcut(event) && enableClipboardPaste) {
      // Do not enter cell edit mode on paste
      return false;
    }
    return initialValue;
  }, [enableClipboardPaste]);
  useGridApiEventHandler(apiRef, 'cellKeyDown', handlePaste);
  useGridApiOptionHandler(apiRef, 'clipboardPasteStart', props.onClipboardPasteStart);
  useGridApiOptionHandler(apiRef, 'clipboardPasteEnd', props.onClipboardPasteEnd);
  useGridRegisterPipeProcessor(apiRef, 'canStartEditing', checkIfCanStartEditing);
};